% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,english]{FITthesis}[2012/10/20]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage{graphicx} %graphics files inclusion
% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation
\usepackage{listings}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{rgb}{0.8,0.8,0.8}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  basicstyle=\scriptsize\ttfamily,        % the size of the fonts that are used for the code
  breaklines=true,
  frame=single,
  rulecolor=\color{lightgray},
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=7pt,
  numberstyle=\tiny,
  language=Java,
  keywordstyle=\color{blue},
  commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},
  numberstyle=\tiny\color{mygray},
}


%\usepackage{color}
\usepackage{multirow}

%\usepackage{minted}

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% EDIT THIS
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Department of Software Engineering}
\title{Framework for similarity search in chemical structures database}
\authorGN{Martin} %author's given name/names
\authorFN{Mates} %author's surname
\author{Martin Mates} %author's name without academic degrees
\authorWithDegrees{Bc. Martin Mates} %author's name with academic degrees
\supervisor{RNDr. David Hoksza, Ph.D.}
\acknowledgements{THANKS}
\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}
\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\setsecnumdepth{part}
\chapter{Introduction}



\setsecnumdepth{all}
\chapter{The problem, specification and goals}
In the world of chemistry every company or organization has its own warehouse of chemical compounds for their needs. These warehouses are often very large. Pharmaceutical companies for instance rarely have less than thousands of various chemicals.

A variety of enterprise software solutions for working with chemical compounds is available today. These programs serve primarily as an internal warehouse management of chemicals and, as in every store, the most common task is to find something very quickly.

In common warehouses objects are organized according to various criteria, such as name, identification number, or category. It works the same way in chemical warehouses. The problem is that not every molecule has its own simple name or has multiple, categorization is difficult, and the identification number must be known in advance. For this reason the storage of chemicals is searched in a slightly different way.

Each molecule has a molecular formula, and it is possible to draw it using the chemical structure diagram. This is the most common way to exchange information in the chemical industry and it is the natural language of chemists. Enterprise systems respect this and allow search by drawing a structure diagram (see Section \ref{structureDiagramRef}).

Nowadays work with these programs is very common for chemists. They draw the desired structure or its part and the system searches the database in order to find the requested molecule. This is called an exact search and a substructure search.

These search methods are good enough if we have a better idea of what we are looking for. However chemists need to find compounds similar to what they drew much more often. This is where similarity search takes its place. Similarity can be defined arbitrarily, for example as a comparison of molecular weight.

\section{Motivation and current state}
Companies in the chemical industry producing chemical compounds often offer them for sale. This is a well-established business and a lot of manufacturers own patents and are exclusive suppliers. The customer is most likely another company in the field of chemistry. Fow example, a pharmaceutical company needs a variety of compounds for drug production or research. Compounds come from many different vendors and they all need to offer or promote their molecules in an effective way.

Compound manufacturers provide catalogues in paper form with structure diagrams, catalog numbers and some properties description. Searching in these catalogues is very inefficient since they are often hundreds of pages long. However, this form of propagation is very common.

Another option that these companies use is the registration of compounds in a public online catalogue such as eMolecules or ChemSpider. These catalogues support different search methods. Exact, substructure and some basic similarity search are commonly included. The main problem of these catalogues is that it is not possible to use their search engine for private purposes or define a custom similarity measure.

In this case, if a customer finds a molecule in the online catalogue, a link to the manufacturer's website is provided and then customer is navigated to the compound detail page where they can buy it. However if the same customer wants to search for something else at the same supplier, they must return to the catalogue and search the entire database again. Search is then performed between all other competitors as well. This isn’t very good for the manufacturer since the customer is leaving its site and may buy at the competing company instead.

Therefore the ideal solution is to provide the customer with a similarity search directly at the manufacturers website or to show them some similar compounds automatically. This is of course possible, but unfortunately there is currently no solution available at a reasonable price. 

Compound manufacturers are thus forced to inquire the development of a custom solution. This is very expensive since almost no web developer or a software company has sufficient knowledge required in the field of chemistry. Software developers therefore use various existing libraries and put them together according to specific requirements or build an application from scratch which is very time-consuming.

\section{Framework idea}
Since compound manufacturers often don’t want to invest as much time and resources into the development of their own custom online search engine, it is expected that the existing open-source solution will be in great demand.

However, in every field of chemical industry a different way of searching is appropriate. Thus it would be very difficult to develop a universal solution that matches all possible needs. A much better idea is to implement a framework that facilitates the creation of such similarity searching and is sufficiently platform-independent for usage on the web. 

This framework should actually be a ready-to-use search engine where a programmer would be able to define the similarity measure in a modular way and run it on any database.

\subsection{Similarity searching}
The main purpose of the framework would be to perform similarity search over chemical database. But what exactly is similarity searching and how does it work?

To perform this kind of search the first thing we need is to specify a query molecule, which is then used to search a database to identify compounds of interest. Search engines basically compare all compounds from databases one by one and look for similarities to the query molecule. 

The second thing necessary is to define what our similarity is. In the world of chemistry it can be a lot of different things. 

\subsection{Exact and substructure similarity}
A simple but very popular form of similarity searching is the detection of structural fragments. Substructure searching is perhaps the most widely used approach to identify compounds of interest. It identifies all the molecules in the database that contain a specified substructure. A simple example would be to identify all structures that contain a particular functional group or sequence of atoms. Figure \ref{fig:substructure_idea} illustrates the idea of substructure searching. It is basically a graph isomorphism problem.

\begin{figure}
  \centering
  \includegraphics[width=9cm]{img/substructure_idea.png}
  \caption{Example of compounds containing Aspirin as a substructure that
can be used as a query for database searching}
  \label{fig:substructure_idea}
\end{figure}


\subsection{Similarity measure over descriptors}
Another form of similarity searching is in molecular descriptors. A simple example of this kind of similarity search is the comparison of molecular weights or count of carbon atoms. But how do we know the molecular weight or number of carbon atoms? These values are called molecular descriptors and as the name suggests these values describe the features of the molecule. Each molecule has its own value for each descriptor and can be computed in advance.

Of course in the real world usage much more complex similarity measures and descriptors are needed and often combine more different approaches.

These descriptors are an integral part of similarity searching and thus should be a part of our framework.


\subsection{Similarity coefficients}
An interesting way of similarity searching is in similarity coefficients. Unlike molecular descriptors these coefficients are always calculated between 2 molecules and thus cannot be calculated in advance. Every query molecule is different and so is the coefficient.

This concept of similarity is important in many fields (not just chemistry) and many different similarity coefficients have been developed. In fact the most similarity coefficients are calculated from molecular descriptors such as binary or hashed fingerprints (see Section \ref{screeningRef}).

The most commonly used coefficients in chemical applications are shown in Figure \ref{fig:coefficients} The Tanimoto coefficient is the most widely used similarity coefficient for binary and hashed fingerprints.\cite{intro}


\begin{figure}
  \centering
  \includegraphics[width=9cm]{img/coefficients.png}
  \caption{Similarity (\textit{S}) or distance (\textit{D}) coefficients in common use for similarity searching in
chemical databases. For binary data \textit{a} is defined as the number of bits set to ``1" in molecule \textit{A},
\textit{b} as the number of bits set to ``1"  in molecule \textit{B} and \textit{c} as the number of bits that are ``1" in both
\textit{A} and \textit{B}.}
  \label{fig:coefficients}
\end{figure}


In our similarity framework these coefficients have to be taken into account. The framework has to provide a way to define this kind of similarity.


\section{State of the Art}
According to my research, RNDr. David Hoksza, Ph.D. my supervisor and Ladislav Drož, Ph.D. CEO of Apigenex s.r.o.\footnote{ Pharmaceutical company selling chemical compounds}, there is no such similarity framework or open-source solution for similarity searching on the web available.

However, many libraries for chemistry are available . These libraries are commercial or open-source and are often used internally in various chemical applications. Each library is designed for a different set of tasks. But what is most in our interest is that some of them can calculate various descriptors or can perform many similarity calculations. I will talk about these libraries later in the implementation part (see Section \ref{chemLibrariesRef}).

Searching for compounds on the web is not new at all. There are many applications running. The problem is that they are often used for searching in public compound databases only, their search engine is not open-source, there is no way to define custom similarity and they cannot be used for private purposes. 

\subsection{ChemSpider}
ChemSpider is a chemistry search engine that has been built with the intention of aggregating and indexing chemical structures and their associated information into a single searchable repository and making it freely available to everybody.\cite{taverna}

This is a very complex solution offering all common ways of searching: exact, substructure and similarity. ChemSpider offers Tanimoto, Tversky and Euclidean coefficients. There is also advanced searching available according to molecular formula, molecular weight and much more. The service is available at: \url{http://www.chemspider.com/}

ChemSpider searches through its own large database of compounds and can be used as a web service.
This service doesn’t offer either search engine for private usage or the definition of custom similarity.  It also can not be used for custom compound database.

\subsection{ChEBI}
The Chemical Entities of Biological Interest (ChEBI) is a freely available database of molecular entities focused on small chemical compounds and it can be found at \url{http://www.ebi.ac.uk/chebi/}. ChEBI incorporates an ontological classification, whereby the relationships between molecular entities or classes of entities and their parents and/or children are specified.\cite{taverna}

ChEBI offers structure and substructure searching and also some filters for molecular mass or charge. There are no similarity coefficients available.

Like ChemSpider there is no option to define custom similarity or to use the search engine for private purposes.

\subsection{PubChem}
PubChem is a free database of chemical structures containing small organic molecules and information on their biological activities provided by the National Center for Biotechnology Information (NCBI), part of the United States National Institutes of Health (NIH). \cite{taverna}

PubChem is located at \url{http://pubchem.ncbi.nlm.nih.gov/} and like ChemSpider or ChEBI it’s a public compound catalogue with advanced similarity searching. However PubChem has the most complex searching options and provides all common methods of similarity.

There is also no option of using the PubChem search engine for private purposes or to define custom similarity.

\subsection{Chemicalize}
Chemicalize is a structure database at \url{http://www.chemicalize.org/} developed by ChemAxon, a leading company providing chemical software development. It contains more than 240 000 compounds and can be searched by structure similarity. Other forms of similarity are missing.

This is also not an open source solution available for custom implementations.

\subsection{eMolecules}
There are various compound vendor catalogues available worldwide and this is probably the largest of them. It is said that 9 of the 10 largest pharmaceutical companies work with eMolecules. It has more than 150 different suppliers to be searched for compounds.\cite{emolecules}

eMolecules are available at \url{http://www.emolecules.com/}. Their search engine is very fast and optimized. Exact, substructure and similarity over Tanimoto coefficient searching options are available.

This is a commercial solution with no possible customization or private use.

\subsection{ChemExper}
In this case we are talking about a compound suppliers catalogue just like eMolecules. This service is less complex and offers only the exact and substructure search. As a commercial implementation there is also no possibility to customize or use it in any way.

\subsection{OrChem}
Unlike the previous solutions this is a chemistry plugin for the Oracle database written in Java. 

Oracle Data cartridges extend the capabilities of the Oracle server. For chemistry various commercial cartridges exist that facilitate searching and analyzing chemical data. OrChem also provides a functionality like this, but is not a cartridge. It doesn't need Oracle's extensibility architecture because its Java components run as Java stored procedures inside the Oracle standard JVM (Aurora).\cite{orchem}

This solution enables the SQL database queries to work with chemical compounds. Using OrChem one can query the Oracle database for similarities using classic SQL commands. By default there is substructure searching and also some basic similarities over descriptors available.

This is an open-source solution so it can be used for custom purposes and for custom repository of compounds. I believe that after deep study of the code, it would be possible to define custom similarities and feature extraction.

It is very promising but the limitation to Oracle database is very binding since compound vendors or pharmaceutical companies rarely use it. The search engine in the framework should be database independent. In addition, the Oracle database is a commercial solution and thus usage of the framework would be dependent on Oracle license purchase.

\subsection{Conclusion}
As we see there are many of real world examples of similarity searching on the web. It is clear that every service has its own implementation and keeps it as precious know-how. It is understandable since this is not a simple application to give out.

There is no ready-to-use solution for similarity searching on the web that could be used for custom compound database and is platform-independent enough. No solution except OrChem provides a way to define custom similarity. 


\chapter{Analysis}
\label{analRef}
As mentioned in previous chapter the main goal of the similarity framework is facilitating implementation of the application for searching in databases of chemical compounds. The framework will provide a modular way to define both feature extraction of molecules (descriptor) and similarity measure of these features. Given a definition of extraction methodology and a definition of similarity a user will be able to simply specify the database of molecules and perform search by similarity with respect to the query molecule. 

\section{Framework as a web service}
One of the main reasons of implementing this framework is searching for compounds on the web. Every web application may be built using a different programming language, framework or different standards. Thus usage of the similarity framework should be platform-independent.

The best way to achieve this is to build a uniform interface for communication over the network. For these purposes the standard solution is to use web service architecture.

\section{Framework features}
According to cheminformatics and compound manufacturers needs discussed in previous chapter, the following list of features summarizes all possible use cases of the framework.\\
Programmer can:
\begin{itemize}
\item Modularly define feature extraction from molecule (descriptor).
\item Modularly define similarity working with these descriptors.
\item Use these descriptors and similarities over any chemical database.
\item Import structures from SDF file to the database
\end{itemize}
Client via web service can:
\begin{itemize}
\item Run any similarity on specified molecule with parameters.
\item Query previous request results with pagination.
\item Obtain information about what similarities are available and what parameters they require.
\item Query how many molecules are in the database.
\item Obtain molecules from database with pagination.
\item Obtain a molecule with a given id from the database.
\item Add new compound to the database.
\end{itemize}


\section{Basic entities of the Framework}
Our similarity framework will operate with these three basic entities: Chemical Compound, Similarity and Descriptor.

\subsection{Chemical Compound}
Chemical Compound is basically an electronic representation of the molecule. I will talk more about data representation of chemical structures later in Chapter \ref{chemicalDataRef}. For now it is an abstraction of compound that Similarity and Descriptor work with. 

It doesn’t matter what compound representation is present in specific databases. Every molecule has to be converted to this representation so the whole framework can operate with it. 

\subsection{Descriptor}
These are numerical values that characterize properties of molecules. Many different molecular descriptors have been described and used for a wide variety of purposes. They vary in the complexity of the information they encode and in the time required to calculate them. In general, the computational requirements increase with the level of discrimination that is achieved. For example, the molecular weight does not convey much about a molecule’s properties but it is very rapid to compute. By contrast, descriptors that are based on quantum mechanics may provide accurate representations of properties, but they are much more time consuming to compute. \cite{intro}

In other words, Descriptor may be a numerical value or an array of values. Framework has to enable computation of these values in advance because, as mentioned before, computation may be very time-consuming. Framework will also provide a way to modularly add any Descriptor. These values are fundamental for similarity searching.

\subsection{Similarity}
\textit{Similarity} is an abstraction of similarity computation between two chemical compounds. It contains an algorithm for comparison that may use one or more molecular descriptors.

Since Framework may be used on top of any database, Similarity has to hold the information about database connection and provide data retrieval.

Similarity may also accept parameters because it can be defined generally. For example, atom count similarity has to know what atoms to count. 

Similarity has to return whether two compounds are similar or not. This will be represented as value between 0 and 1 where 0 means no similarity at all.


\section{Basic framework structure}
The very basic scenario of framework usage is the following (see Fig. \ref{fig:basic_idea}):
\begin{enumerate}
\item The client makes a HTTP request through API (web service) specifying which similarity to use. Client also sends the query molecule.
\item	Application runs selected similarity on query molecule.
\item	Selected Similarity performes searching. It uses descriptors, goes through the whole database and returns results.
\item	A HTTP response is returned to the client containing requested results.
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=11cm]{img/basic_idea.png}
  \caption{Basic framework structure}
  \label{fig:basic_idea}
\end{figure}


\chapter{Implementation}

TODO

\section{Cheminformatics}
During the implementation it was necessary to understand some technical aspects of chemistry. In fact, the problem that the framework faciliates belongs to the field where computer science meets chemistry, to cheminformatics.

Cheminformatics, also known as chemoinformatics and chemical informatics, is the use of computer and informational techniques applied to a range of problems in the field of chemistry. These techniques are used in pharmaceutical companies in the process of drug discovery. These methods can also be used in chemical and allied industries in various other forms. \cite{wiki1}

In literature the term chemoinformatics was first introduced by F.K. Brown in 1998. However the term chemical informatics was already used much earlier and generally understood as the application of information technology to chemistry thus lacks a specific drug discovery focus.\cite{bunin}

The spectrum of chemoinformatics:
\begin{itemize}
\item Chemical data collection, analysis, and management
\item Data representation and communication
\item Database design and organization
\item Chemical structure and property prediction (including drug-likeness)
\item Molecular similarity and diversity analysis
\item Compound or library design and optimization
\item Database mining
\item Compound classification and selection
\item Qualitative and quantitative structure-activity or – property relationships
\item Information theory applied to chemical problems
\item Statistical models and descriptors in chemistry
\item Prediction of compound characteristics in natural environment 
\end{itemize}

\section{Data representation of chemical structures}
\label{chemicalDataRef}
In our similarity framework working with chemical structures in electronic form is the key feature. This section briefly summarizes the basic methods of molecule representation.

Basically we need representation that shows the way in which the atoms and bonds of a molecule are connected together. This is necessary if molecules are to compare. 

Chemical structures are usually stored in a computer as molecular graphs. Graph theory is a well-established area of mathematics that has found application not just in chemistry but also in many other areas, such as computer science. A graph is an abstract structure that contains nodes connected by edges. In our case nodes are atoms and edges are bonds.

Such representation also enables us to display conventional two-dimensional structure diagrams on computer screens, and the performance of a wide variety of other analyses such as descriptor calculations or other complex predicted values.

\subsection{Structure diagram}
\label{structureDiagramRef}
The familiar two-dimensional chemical structure diagram could be considered to
be the “natural language” of the chemist, and in everyday communication chemists almost invariably resort to it as their preferred form of structure representation (see Figure \ref{fig:nomenclature}).

Structure diagrams have found their way into computer-based information systems and their appearance is generally restricted to the user interface. Other types of representation are used internally.

Many “molecule editor” programs are available to enable the user to draw a structure diagram on a computer screen by using a mouse. An internal (usually connection table) representation of the structure is built at the same time.\cite{handbook}

\subsection{Chemical nomenclature}
There are two types of basic chemical nomenclature: trivial and systematic. Trivial is basically the name of the structure. Unfortunately only a limited subset of compounds has their trivial name. On the other hand systematic nomenclature is a description of the compound structure, with fragments (sub-strings) of the name representing structural features (see Figure \ref{fig:nomenclature}).\cite{handbook}

Neither trivial nor systematic nomenclature was designed as a computer representation of chemical structures.

\begin{figure}
  \centering
  \includegraphics[width=11cm]{img/nomenclature.png}
  \caption{2D structure diagram with some corresponding names}
  \label{fig:nomenclature}
\end{figure}


\subsection{Line Notations}
One way to represent and communicate a molecular graph is through the use of a linear notation. Line Notations are representations of molecular structures in the form of linear strings of alphanumeric symbols. They were first developed before computers became generally available, and were intended as manual ciphering tools, more convenient to use than systematic nomenclature. 

Their compactness, however, made them especially suitable for use in computer systems at a time when computer storage was limited. Line notations were the predominant form for full computer representation of chemical substances during the 1960s and 1970s.\cite{handbook}

An early line notation that became quite widely used was the Wiswesser Line Notation (WLN). This uses a complex set of rules to represent different functional groups and the way they are connected in the molecule. A recent linear notation that has found widespread acceptance is the Simplified Molecular Input Line Entry Specification (SMILES) notation.

One reason for the extensive use of SMILES is that it is much easier to use and comprehend than the WLN. Just a few rules are needed to write and understand most SMILES strings.

In SMILES, atoms are represented by their atomic symbol. Hydrogen atoms are not normally explicitly represented. Double bonds are written using ``='' and triple bonds using ``\#''. Single and aromatic bonds are not explicitly represented by any symbol. 

To construct a SMILES string one needs to iterate through the chemical structure in such a way that all the atoms are visited just once. Rings are dealt with by breaking one of the bonds in each ring. Appending an integer to the two atoms of the broken bond then indicates the presence of the ring. As one progresses through the molecule one will usually arrive at branch points, where more than one possible avenue could be followed. The presence of a branch point is indicated using a lefthand bracket. A right-hand bracket indicates that all the atoms in that branch have been visited. Branches can be nested to any level necessary (see Figure \ref{fig:smiles}).\cite{intro}

\begin{figure}
  \centering
  \includegraphics[width=12cm]{img/smiles.png}
  \caption{Some examples of the SMILES strings for a variety of molecules}
  \label{fig:smiles}
\end{figure}

\subsection{Connection table}
Another way to communicate the molecular graph to and from the computer is to use a connection table. 

The simplest type of connection table consists of two sections: first, a list of the atomic numbers of the atoms in the molecule and second a list of the bonds, specified as pairs of bonded atoms. More detailed forms of connection table include additional information such as the hybridisation state of each atom and the bond order. One key point to note is that hydrogen atoms may not necessarily be explicitly included in the connection table (i.e. they may be implied) in which case the connection table is hydrogen-suppressed. Information about the coordinates of the atoms may also be present to enable a standard chemical drawing to be produced or for use in a molecular graphics program.\cite{intro}

\subsubsection{MDL format}
\label{mdlFormatRef}

A perfect example of the connection table is the MDL format developed by MDL Information Systems. This format is used to store compounds in the example database of our similarity framework. Example for aspirin is shown in Figure \ref{fig:mdl}.

\begin{figure}
  \centering
  \includegraphics[width=12cm]{img/mdl.png}
  \caption{The connection table for aspirin in the MDL format (hydrogen-suppressed form).
The numbering of the atoms is as shown in the chemical diagram.}
  \label{fig:mdl}
\end{figure}

\subsubsection{Structure Data Format (SDF)}
Like MDL Molfile, SDF is one of the family of chemical-data file formats developed by MDL Information Systems. It is intended especially for structural information. SDF stands for structure-data file, and SDF files actually wrap the MDL Molfile. Multiple compounds are delimited by lines consisting of four dollar signs (\$\$\$\$). A key feature of the SDF format is its ability to include associated data. These data include for example the amount of the compound on store or internal identification number.

The SDF format became the most widely used standard for importing and exporting information on chemicals.\cite{sdf}  

Virtually all chemical database applications used for structure searching of chemical information are capable of importing and exporting SDF files these days.\cite{sdf2}

As we see, SDF is the most commonly used format for chemical data exchange and thus the similarity framework use MDL Molfile and SDF files as well.


\section{Libraries for cheminformatics}
\label{chemLibrariesRef}
As mentioned in previous chapters, it is necessary to work with many chemical-related computations such as descriptor or coefficient calculations, substructure searching, drawing structure diagrams on screen and many others.

It is not the objective of the framework to implement such functionalities but to enable the programmer to use any open-source library arbitrarily. What is needed, however, is the ability to work with chemical data in the general way like reading and saving chemical files or some basic molecule manipulations. Of course some basic similarities have to be implemented as an example. 

A lot of chemical libraries are available these days and it was necessary to choose one very carefully.


\subsection{RDKit}
RDKit describes itself as cheminformatics and machine learning software.  It is written in C++ with Python bindings and was designed for working with molecules like looping over atoms and bonds, modifying structures, reading molecules from various file formats or drawing molecules on the screen. 

This library also computes various molecular descriptors and coefficients. Available similarity metrics include Tanimoto, Dice, Cosine, Sokal, Russel, Kulczynski, McConnaughey, and Tversky. Substructure matching is also present.

The whole project is very well documented with various examples on the project website: \url{http://rdkit.org/}.
This library is very complex and apparently satisfies all the needs of the similarity framework.


\subsection{Open Babel}
Open Babel is a chemical toolbox designed to speak in many languages of chemical data. It's an open, collaborative project allowing anyone to search, convert, analyse, or store data from molecular modelling, chemistry, solid-state materials, biochemistry, or related areas.\cite{babel}

Open Babel offers writing and converting of over than 110 chemical file formats, molecular searching over line notations and like RDKit, is designed for manipulation of chemical data.

This project offers a ready-to-use programmer’s toolkit including C++, Perl and Python interfaces. Unfortunately descriptors, similarity metrics and substructure matching are missing. 

This library was clearly designed only as a wrapper for chemical data and doesn’t aim at similarities at all. This is not necessarily a disadvantage because the definition of similarities and descriptors in our framework lies in the hands of the programmer and they may use any library they choose to. 

Open Babel is available at \url{http://openbabel.org/}


\subsection{Chemistry Development Kit}
The Chemistry Development Kit (CDK) is a Java library for structural chemo- and bioinformatics. It is now developed by more than 50 developers all over the world and used in more than 10 different academic as well as industrial projects worldwide\cite{cdk2}. While the CDK project was founded in 2000, the code base originates from the groundbreaking open source cheminformatics work Christoph Steinbeck started in 1997.\cite{cdk}

This library is also very complex and tries to satisfy all possible needs of cheminformatics. According to documentation at \url{http://sourceforge.net/apps/mediawiki/cdk/} it can do much more than RDKit. CDK offers many descriptor computations, all common similarity coefficients, structure searching and a very robust interface for atom and molecule manipulation. 

CDK is considered the most reliable and complex solution by many and is actively developed by its community so there are chances that implementation will be bug free. On the project website there is also a list of various real-world applications using CDK as their core library for chemicals.


\subsection{MayaChemTools}
Unlike CDK or RDKit this library is designed to be lightweight and fast. It is basically a set of Perl scripts. MayaChemTools is designed for fast computation of descriptors and many similarity coefficients. In fact it has 26 coefficients, more than all other libraries.


\subsection{E-Dragon}
E-Dragon is the electronic remote version of the well-known software DRAGON, which is an application for the calculation of molecular descriptors developed by the Milano Chemometrics and QSAR Research Group of Prof. R. Todeschini. These descriptors can be used to evaluate molecular structure-activity or structure-property relationships, as well as for similarity analysis and screening of molecule databases. Dragon provides more than 1 600 molecular descriptors that are divided into 20 logical blocks. The first release of Dragon dates back to 1997.\cite{dragon} 

This is in fact an on-line version of commercial software and cannot be used internally by the framework.

\subsection{Conclusion}
According to the information available, the best candidates were CDK and RDkit. They are both very complex and would satisfy all needs of the framework. They are also both well documented. Finally CDK was chosen because of its strong foundation in the academic community and recent active development. Another advantage of the CDK is its implementation in Java since Java EE is the ideal environment for web application development.


\section{Working with CDK}
As mentioned in the previous chapter, CDK is designed to implement cheminformatics software and thus can manage many different tasks. Key features for our framework are the wrapper for molecules, descriptor calculations and structure searching.

\subsection{Atoms, bonds and molecules in CDK}
The basic objects in the CDK are the \textit{IAtom}, \textit{IBond} and \textit{IAtomContainer}. The name of the latter is somewhat misleading, as it contains not just \textit{IAtoms} but also \textit{IBonds}. The primary use of the model is the graph-based representation of molecules, where bonds are edges between two atoms being the nodes.\cite{cdk}

\subsubsection{Atoms}
The CDK interface \textit{IAtom} is the underlying data model of atoms. Creating a new atom is very easy. For example, we can create an atom of an element type carbon, as defined by the element's symbol that we pass as parameter in the constructor (See Fig. \ref{cdkAtomCode}).

\begin{figure}
\begin{lstlisting}
IAtom atom = new Atom("C");
\end{lstlisting}
\caption{Carbon atom inicialization in CDK}
\label{cdkAtomCode}
\end{figure}

A CDK atom has many properties, many of them inherited from the \textit{IElement}, \textit{IIsotope} and \textit{IAtomType} interfaces. Figure \ref{fig:cdkAtomModel} shows the interface inheritance specified by the CDK data model. 

\begin{figure}
  \centering
  \includegraphics[width=3cm]{img/cdk-atom.png}
  \caption{The \textit{IAtom} interface extends the \textit{IAtomType} interface,
which extends the \textit{IIsotope} interface, which, in turn, extends
the \textit{IElement} interface.}
  \label{fig:cdkAtomModel}
\end{figure}

The most common properties of \textit{IElements} are their symbol and atomic number. \textit{IIsotope} information adds mass number, exact mass and natural abundance. Finally the \textit{IAtomType} interface contains fields that relate to atom types. These properties include formal charge, neighbor count, maximum bond order and atom type name. Atom types are an important concept in cheminformatics. They describe some basic facts about that particular atom in a particular configuration. These properties are used in many cheminformatic algorithms, including adding hydrogens to hydrogen-depleted chemical graphs.\cite{cdk}

\subsubsection{Bonds}
The \textit{IBond} interface of the CDK is an interaction between two or more \textit{IAtoms}. While the most common application in the CDK originates from graph theory, it is not restricted to that. That said, many algorithms implemented in the CDK expect a graph theory based model, where each bond connects two, and not more, atoms.

For example if we want to create ethanol (See Fig. \ref{fig:ethanol}) in CDK, first we define all atoms and then two bonds between them (See Fig. \ref{cdkEthanolCode}).

\begin{figure}
  \centering
  \includegraphics[width=6cm]{img/ethanol.png}
  \caption{Chemical structure diagram of Ethanol}
  \label{fig:ethanol}
\end{figure}

\begin{figure}
\begin{lstlisting}
IAtom atom1 = new Atom("C")
IAtom atom2 = new Atom("C")
IAtom atom3 = new Atom("O")
IBond bond1 = new Bond(atom1, atom2, IBond.Order.SINGLE);
IBond bond2 = new Bond(atom2, atom3, IBond.Order.SINGLE);
\end{lstlisting}
\caption{Ethanol inicialization in CDK}
\label{cdkEthanolCode}
\end{figure}


\subsubsection{Molecules}
We already saw in the previous pieces of code how the CDK can be used to create molecules, and while the above is strictly enough to find all atoms in the molecule starting with only one of the atoms in the molecule, it often is more convenient to store all atoms and bonds in a container. 

The CDK has two main containers, which are identical in functionality, but which have different semantics: the \textit{IAtomContainer} and the \textit{IMolecule}. The first is a general container that holds atoms and bonds, while the \textit{IMolecule} has the added implication that it is meant that the container holds a single molecule, of which all atoms are connected to each other via one or more covalent bonds. It is important to note that the latter is not enforced.\cite{cdk}

\textit{IAtomContainer} is very important because in our framework similarity and descriptor interfaces expect this type as parameter. Using CDK, \textit{IAtomContainer} can be created from all common chemical representations such as five versions of MDL molfile, SDF file, HyperChem and many others.



\section{Core entities of the framework}
\label{coreEntit}
Thanks to the CDK library we are able to work with chemicals and thus it is time to design the structure of the whole framework. Class diagram in Figure \ref{fig:classDiagram} illustrates the final structure. Both similarity and descriptor can be defined modularly. Similarity \textit{AtomCountSimilarity} is shown as an example and is based on number of atoms present in molecule.

\begin{figure}
  \centering
  \includegraphics[width=13cm]{img/Class.png}
  \caption{Class diagram of basic entities in the framework}
  \label{fig:classDiagram}
\end{figure}

\subsection{Abstraction of chemical compound}
Implementation of the \textit{ICompound} interface represents chemical structure through the whole framework. This is basically a wrapper for database molecule, which all similarities, descriptors and algorithms are designed to work with. \textit{IAtomContainer} from the CDK library that all compounds contain, achieves this. Every time any molecule is retrieved from any repository it has to be converted to this type.

Of course this could be very limiting because a programmer may not want to use CDK in their descriptors. Fortunately the \textit{IAtomContainer} can be freely converted to any format. So if the programmer uses any other chemical toolkit working, for example with Mol2 format\cite{mol2}, they can use CDK to convert \textit{IAtomContainer} to Mol2 and pass it to the custom descriptor.

List of all methods that the ICompound interface defines:

\begin{itemize}
\item \textit{getAtomContainer()} \\ In this method the programmer should specify conversion of arbitrary chemical representation to \textit{IAtomContainer}. The CDK library is ideal for this purpose since it can create this container from all commonly used formats.
\item \textit{getId() and setId(id)}  \\ These are getter and setter for compound id. Every compound should represent the structure from a database and thus it should have its id. These ids are also stored in similarity result after similarity searching.
\end{itemize}


\subsection{Abstraction of similarity}
\label{similarityAbstractRef}
All similarity methods are specified in the \textit{ISimilarity} interface and their detailed descriptions are shown in the following list. 

\begin{itemize}
\item \textit{findAllSimilar()} \\ In this method the similarity algorithm should be specified. This method is meant for an algorithm that goes through a given data set and uses predefined similarities for similarity matching.
\item \textit{screen(start, limit)}  \\ The method is responsible for fast compound screening (see Section \ref{screeningRef}). This method should retrieve a batch of compounds from a database and perform rapid pre-elimination of inappropriate compounds, for example using structural fingerprint comparison. 

If there are no more compounds in the database, \textit{NoMoreCompoundsException} is thrown marking the end of whole searching.

\item \textit{calculateSimilarity(compound)}  \\ This is a place for the computation of a given and query compound. This method returns a value between 0 and 1 where 0 marks no similarity at all. This is where the programmer uses descriptors and defines similarity metrics. Function is called by default from loop in the \textit{findAllSimilar()} method of the \textit{AbstractSimilarity} class (see Section \ref{abstractSimilarityRef}).

\item \textit{getCompounds(start, limit)}  \\ The method is responsible for compound retrieval from the database. This is the place where database connection should be defined or used. 

\item \textit{getCompoundById(id)}  \\ This method should return one compound from the database identified by its id. The method is needed when similarity results are known and client calls for a specific compounds. This is the place where database connection should be defined or used.

\item \textit{setParameters(parameters)}  \\ This is a setter for similarity parameters and place where parameter validation should be implemented.

\item \textit{getParameters()}  \\ This is a simple getter for similarity parameters. 

\item \textit{getParameterNames()}  \\ This is a simple getter for returning parameter names. This is needed for a client asking for a similarity parameters definition. 

\item \textit{getParameterType(name)}  \\ This method accepts the name of the parameter and returns its type. This is needed for a client asking the similarity parameters definition.

\item \textit{getRequestCompound() and setRequestCompound(ICompound)}  \\ These methods represent the setter and getter for query compound implementing \textit{ICompound} interface. Algorithm search uses it in order to find similarities in database.

\end{itemize}



\subsection{Default implementation of similarity}
\label{abstractSimilarityRef}
Basic implementation of the \textit{ISimilarity} interface is present in the \textit{AbstractSimilarity} class and defines default functionality for other similarities and implements algorithm for finding similar structures in the database. The algorithm is described in the activity diagram in Figure \ref{fig:activityDiagram}.

\begin{figure}
  \centering
  \includegraphics[width=13cm]{img/Flow.png}
  \caption{Activity diagram of the basic similarity algorithm}
  \label{fig:activityDiagram}
\end{figure}

Of course the programmer can override this method and define the behavior arbitrarily. This method is called from  the web service and returns a set of all similar compounds.

This abstract class contains several protected variables that may be configured:
\begin{itemize}
\item \textit{List$<$SimilarityResult$>$ similarCompounds} \\ This is the list containing similar compounds that have been found so far. Only compound identification number and its similarity is stored in the object called \textit{SimilarityResult} (see Section \ref{memoryConsumptionRef}).
\item \textit{ICompound requestCompound} \\ A simple object storing information about the query compound implementing \textit{ICompoud} interface.
\item \textit{Integer batchSize = 1000} \\ We don’t want to process all compounds from the database at once and therefore molecules from the database are retrieved and inspected in batches. This is for memory consumption reasons (see Section \ref{memoryConsumptionRef}).
\item \textit{Double threshold = 0.8} \\ The threshold specifies the minimum similarity of interest. Less similar compounds will be skipped. Defaults to 80\%.
\item \textit{Integer numberOfResults = 100000} \\ For scalability reasons the maximum number of results must be limited. The default value is set to 100 000 (see Section \ref{memoryConsumptionRef}).
\end{itemize}

\textit{AbstractSimilarity} also defines default screening. This screening does nothing. It only returns retrieved compounds from the database and throws \textit{NoMoreCompoundsException} when all compounds are checked.




\subsection{Abstraction of the descriptor}
All descriptors are in fact very simple classes implementing the \textit{ICompoundDescriptor} interface. There is only one method defined, called \textit{calculate} expecting the \textit{IAtomContainer} as the parameter returning any object. This method is responsible for descriptor calculation and may return any data type as the result.

This is sufficient for molecular descriptors because they may be computed from the molecule itself but not for similarity coefficients. If there is a need to compute a distance coefficient between two molecules, descriptor implementation should have a private variable representing the request molecule.


\section{Scalability of the framework}
\label{scalabilityRef}
Since it is not rare that chemical databases contain thousands of compounds, it is clear that scalability will be a great issue. However it’s not the main goal of the framework to optimize different kinds of similarity searching. It far exceeds the scope of this thesis and it is a large discipline in cheminformatics. Scalability of specific similarity lies in the hands of the programmer. 

Nevertheless, scalability has to be discussed because the framework must be ready for working with large data sets and has to provide sufficient interface for most possible cases. In addition, few similarities were implemented as an example and were observed to be very slow with increasing number of compounds.

First of all we have to consider databases with millions of molecules. In some cases similarity queries may return 80-90\% of all compounds. For instance substructure searching for benzene ring that is extremely common will return most of the compounds.  It would be very unreasonable to keep all these results in memory or even worse try to send them all to the client through an HTTP protocol. 

\subsection{Memory consumption}
\label{memoryConsumptionRef}
The main concern is of course memory consumption, considering that the compound is saved as a MDL connection table and thus can be represented as a \textit{String} object (see Section \ref{mdlFormatRef}). We also assume that the average MDL file contains about 2300 characters (may be much more in specific databases). 

In order to find out how much memory our search result will consume, we need to look at some Java primitive types, references and objects. 

In Java every \textit{Char} type takes 2 bytes of memory, \textit{Integer} takes 4 bytes, reference to the object consumes 4 bytes and finally any object in Java needs additional 8 bytes for header information. Arrays consume the same as the object plus 4 bytes representing Integer holding information about array length.  

As mentioned earlier one compound is represented as a \textit{String} object. Every \textit{String} in Java consists of the following:
\begin{itemize}
\item \textit{Char} array containing the actual characters,
\item \textit{Integer} offset into the array at which the string starts,
\item \textit{Integer} for length of the string,
\item \textit{Integer} for the cached calculation of the hash code.
\end{itemize}

An empty \textit{String} thus consists of 8 bytes for the object header, 4 bytes for \textit{Char} array reference, 12 bytes for the \textit{Char} array object header and 4*3 bytes for 3 \textit{Integers}. That gives us 36 bytes. However objects in Java occupy a number of bytes that is a multiple of 8 so we need to add 4 bytes of padding. An empty \textit{String} thus needs 40 bytes of memory.

If the \textit{String} contains 2300 characters, then the required memory usage is the empty \textit{String} (40 bytes) plus 2300*2=4600 bytes for \textit{Chars}. That gives us 4640 bytes and since it is multiple of 8 it is the final memory consumption.

If the result of similarity searching gives us for example 100 000 compounds, the minimum memory taken up is about 442 MB. One milion compounds would use 4.32GB. And yet we are not taking into account that in our framework these results are part of another object and shall use some additional bytes for each. Nevertheless with a few concurrent searches this would cause memory overload very quickly. This is why the results of the similarity searching are saved differently and the maximum number of results is controlled.

In the final implementation only the identification number of the compound and its computed similarity is kept in the memory in an object called \textit{SimilarityResult}. This object consumes 8 bytes for header information, 8 bytes for type \textit{Double} representing similarity and 8 bytes for id of type \textit{Long}. That gives us 24 bytes for each result. This means that 100 000 results will take up only about 2.3 MB of memory.

Similarity itself then needs to be able to retrieve actual compounds from database by id and since every similarity has to implement such method from the \textit{ISimilarity} interface everything will work perfectly.

Considering to the discussion above it was decided to set the limit of maximum possible results to 100 000. It is assumed that in the real world usage, no more results are needed. This behaviour can be changed in the \textit{AbstractSimilarity} class.

For the same reasons similarity searching is not performed for all compounds at once but they are retrieved from database in batches (see Fig. \ref{fig:activityDiagram}).

The memory issue has also impact on the client side of the framework. When the client sends the similarity request over an HTTP protocol, they receive only the number of results and identification number for the session as response (see Fig. \ref{fig:basic-1}). During the same session the client can send another request for a specific part of the results. Under these circumstances the client can easily paginate the results with low system memory consumption and small data transfer (see Fig. \ref{fig:basic-2}).

\begin{figure}
  \centering
  \includegraphics[width=13cm]{img/basic-1.png}
  \caption{Workflow of the framework during the \textit{AtomCount} similarity request}
  \label{fig:basic-1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=13cm]{img/basic-2.png}
  \caption{Workflow of the framework during the request for results of previous \textit{AtomCount} similarity searching}
  \label{fig:basic-2}
\end{figure}


\subsection{Speed and CPU usage}
Assuming we have millions of compounds in the database and every compound has to be inspected for similarity every time searching is initiated, the whole implementation may be very slow. As mentioned before it’s not the goal of this thesis to optimize all different kinds of similarity searching. However the topic has to be discussed so the framework is able to provide appropriate tools.

There are two ways of how similarity searching may be optimized. The first way is to optimize the algorithm for similarity and descriptor computation and the second is to search more effectively and perform some sort of multi-stage searching mechanism.

Every similarity is unique and has to be optimized in a different way.

\subsubsection{Scalability of substructure similarity}
A substructure search identifies all the molecules in the database that contain a specified substructure. Substructure searching is perhaps the most widely used approach to identify compounds of interest and thus is implemented as an example in our framework. Despite of the fact that this similarity is quite simple to understand it may by very time consuming to perform.

According to graph data representation of compounds discussed in the Section \ref{chemicalDataRef} graph, theoretic methods can be used to perform substructure searching, which is equivalent to determining whether one graph is entirely contained within another, a problem known as subgraph isomorphism. Efficient algorithms for performing subgraph isomorphism are well established, but for large chemical databases they are usually too slow to be used alone. 

The subgraph isomorphism belongs to a class of problems known as NP-complete\cite{npcomplete}, meaning that to find a solution all algorithms require an amount of time that varies exponentially with the size of the problem. 

The ``brute-force'' approach to subgraph isomorphism involves testing every possible way to map the nodes of the substructure graph onto those of the database molecule. Unfortunately, if there are $N_S$ nodes in the substructure query and $N_M$ nodes in the database molecule then there are $\frac{N_M!}{(N_M-N_S)!}$ possible mappings that must be tested.\cite{intro} It is clear that even for very small substructures and molecules with modest numbers of atoms this is an impractical approach. 

Fortunately, more efficient methods are available but still, it is characteristic of NP-complete problems that no fast solution to them is known. That is, the time required to solve the problem using any currently known algorithm increases very quickly as the size of the problem grows.

For this reason most chemical database systems use a two-stage mechanism to perform substructure search. 

The first step involves the use of screening to rapidly eliminate molecules that cannot possibly match the substructure query. The aim is to discard a large proportion (ideally more than 99\%) of the database. The structures that remain are then subjected to the more time-consuming subgraph isomorphism procedure to determine which of them truly do match the substructure. 

Molecule screens are often implemented using binary string representations of the molecules and the query substructure called bitstrings or fingerprints. These bitstrings consist of a sequence of ``0"s and ``1"s. They can be compared and manipulated very rapidly, especially if held in the computer’s memory. A ``1" in a fingerprint usually indicates the presence of a particular structural feature and a ``0" its absence (see Fig. \ref{fig:structureFingerprint}). Thus if a feature is present in the substructure (there is a ``1" in its fingerprint) but not in the molecule (the corresponding value is ``0") then it can be readily determined from the fingerprint comparison that the molecule cannot contain the substructure.\cite{intro}

\begin{figure}
  \centering
  \includegraphics[width=13cm]{img/structurefingerprint.png}
  \caption{The bitstring representation of a query substructure is illustrated together with the
corresponding bitstrings of two database molecules. Molecule A passes the screening stage since
all the bits set to ``1" in the query are also set in its bitstring. Molecule B, however, does not pass
the screening stage since the bit representing the presence of O is set to ``0" in its bitstring.}
  \label{fig:structureFingerprint}
\end{figure}


\section{Screening and fingerprints}
\label{screeningRef}
We see that screening using fingerprints plays the key role in scalability of substructure searching. However screening is used in may other similarities as well and thus many different fingerprint methods were developed. Screening using these fingerprints is called binary screening and is considered to be very fast.

Most binary screening methods use one of two approaches. In a structural key approach, each position in the fingerprint corresponds to the presence or absence of a predefined substructure or molecular feature. This is often specified using a fragment dictionary. The \textit{i}th substructure in the dictionary corresponds to the \textit{i}th bit in the fingerprint. 

It is necessary to design the dictionary according to the molecules expected to be stored in the database and also to consider typical queries that might be submitted.

The alternative to structural fingerprints is using a hashed fingerprint, which does not require a predefined fragment dictionary, and so in principle has the advantage of being applicable to any type of molecular structure. In structural fingerprints the choice of dictionary included has a critical effect on the search speed across the databases. An effective choice will screen out virtually all structures that aren't of interest, greatly increasing search speed, whereas a poor choice will cause many false hits, which slows searching to an intolerable level. 

Hashed fingerprints address this lack of generality by eliminating the idea of pre-defined patterns. A fingerprint is a bit array, but unlike a structural key there is no assigned meaning to each bit. Hash fingerprint characterizes the pattern, but the meaning of any particular bit is not well defined. 

It is produced by generating all possible linear paths of connected atoms through the molecule containing between one and a defined number of atoms (typically seven). Each pattern serves as a seed to a pseudo-random number generator, the output of which is a set of bits (typically 4 or 5 bits per pattern). The set of bits thus produced is added to the fingerprint with a logical OR.\cite{daylight}

In spite of the difference between the meaning of a hashed and structural fingerprint's bits, hashed fingerprints share an important feature with the structural. If a pattern is a substructure of a molecule, every bit that is set in the pattern's fingerprint will be set in the molecule's fingerprint. This means that, like structural keys, we can use simple bit operations on fingerprints to screen molecules as we search a database, making a fingerprint comparison an extremely fast screen for searching.\cite{daylight}

In conclusion, it should be noted that binary screening plays a major role and therefore is an integral par of the framework. In fact any fingerprint is a special case of the descriptor and basic algorithm designed for similarity searching has its screening part. The screening itself has its place in \textit{ISimilarity} interface (see Section \ref{similarityAbstractRef}). 










\section{Framework as a web service}

As mentioned in Chapter \ref{analRef} the main purpose of this framework is to search for molecule similarities on the web. At the same time framework has to be versatile as much as possible and thus usage has to be platform independent. In other words framework will be running as a separate unit providing a uniform application interface (API) for communication with clients over the network. This is called Service Oriented Architecture. On the web the ideal solution to achieve this is to use web service architecture.

Web services are said to be “loosely coupled” because the client of a web service doesn’t have to know its implementation details (such as the language used to develop it or the method signature). The consumer is able to invoke a web service using a self-explanatory interface describing the available business methods (parameters and return value). The underlying implementation can be done in any language (Visual Basic, C\#, C, C++, Java, etc.). A consumer and a service will still be able to exchange data in a loosely coupled way using XML documents. A consumer sends a request to a web service in the form of an XML document, and, optionally, receives a reply, also in XML. It should be noted that another form of documents called JSON (JavaScript Object Notation) is used more often these days.

For a consumer to communicate with a web service, a way to send messages to each other is needed. Messages can be transported over a network using a protocol that both parties can support. Given that web services are used mostly on the web, they usually use HTTP, but they can also use other network protocols such as HTTPS (Secure HTTP), TCP/IP, SMTP (Simple Mail Transport Protocol), FTP (File Transfer Protocol), and so on.\cite{java} Our framework will use standard HTTP protocol for communication over the Internet. 

\subsection{Hypertext Transfer Protocol (HTTP)}
Although web services may use different network protocols we will mainly focus on HTTP, which is the most used protocol on the web. 

The main feature worth to be mentioned is that HTTP communication is state-less. It means that functions are called as a request-response between client and the server. No states are kept between requests.

For instance the client submits an HTTP request message to the server. The server, which provides resources such as HTML files and other content, or performs other functions on behalf of the client, returns a response message to the client. The response contains completion status information about the request and may also contain requested content in its message body.

HTTP also defines methods to indicate the desired action to be performed on the identified resource. List of most common HTTP methods follows\cite{http}:

\begin{itemize}
\item \textbf{GET} - Requests a representation of the specified resource. Requests using GET should only retrieve data and should have no other effect.
\item \textbf{HEAD} - This method is identical to GET but in this case server is not expected to send back response body.
\item \textbf{POST} - Requests that the server accept the entity enclosed in the request as a new subordinate of the web resource identified by the URI.
\item \textbf{PUT} - Requests that the enclosed entity be stored under the supplied URI.
\item \textbf{DELETE} - Deletes the specified resource.
\end{itemize}

The structure of the HTTP request or response is quite simple and consists of the header containing detailed information about the response/request and the body with the actual content if there is any. Example of the simple HTTP request is shown in Figure \ref{httpGet} and request in Figure \ref{httpResponse}.

\lstset{ 
  language=HTML,
}

\begin{figure}
\begin{lstlisting}
GET /index.html HTTP/1.1
Host: www.example.com
\end{lstlisting}
\caption{Example of simple HTTP GET request.}
\label{httpGet}
\end{figure}



\begin{figure}
\begin{lstlisting}
HTTP/1.1 200 OK
Date: Mon, 23 May 2013 22:38:34 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 131
Connection: close

<html>
<head>
  <title>An Example Page</title>
</head>
<body>
  Hello World, this is a very simple HTML document.
</body>
</html>

\end{lstlisting}
\caption{Example of HTTP response.}
\label{httpResponse}
\end{figure}

\lstset{ 
  language=Java,
}

The first line of the response informs the consumer of the HTTP version in use, a status code (such as 404 or 200), and a reason explaining the code. The first digit of the code indicates the class of the status. To quote from the HTTP specification\cite{http}:

\begin{itemize}
\item \textbf{1xx} - Informational - Request received, continuing process.
\item \textbf{2xx} - Success - The action was successfully received, understood, and accepted.
\item \textbf{3xx} - Redirection - Further action must be taken in order to complete the request.
\item \textbf{4xx} - Client Error - The request contains bad syntax or cannot be fulfilled.
\item \textbf{5xx} - Server Error - The server failed to fulfill an apparently valid request.
\end{itemize}

The next parts of the header may vary but following fields are usually defined:

\begin{itemize}
\item \textbf{Accept} - Content types that are acceptable for the response.
\item \textbf{Accept-Encoding} - Acceptable encodings of the request body.
\item \textbf{Connection} - What type of connection the user-agent would prefer or options that are desired for connection.
\item \textbf{Content-Length} - The length of the request/response body in 8-bit bytes.
\item \textbf{Content-Type} - The MIME\cite{mime} type of the body of the request/response.
\item \textbf{Date} - The date and time that the HTTP message was sent.
\item \textbf{Host} - The domain name of the server.
\item \textbf{User-Agent} - The information about the software or device from which the request was sent.
\item \textbf{Content-Encoding} - The type of encoding used on the data in response body.
\item \textbf{Expires} - Gives the date/time after which the response is considered stale.
\item \textbf{Server} - A name for the server that sent the response.
\item \textbf{Transfer-Encoding} - The form of encoding used to safely transfer the entity to the user.
\end{itemize}

There are many more HTTP headers that may bee seen in the real world usage. Nevertheless the above are the most common ones. Detailed specification of the HTTP protocol is very important for our framework because it is the only way it will communicate with the outside world.

\subsection{Choosing web service architecture}
There are two web service architectures to choose from: Simple Object Access Protocol (SOAP) and Representational State Transfer (REST). Many factors must be taken into account when making a choice between SOAP web services and RESTful web services.

\subsubsection{Simple Object Access Protocol (SOAP)}
SOAP is the standard web services application protocol. It provides the communication mechanism to connect web services exchanging formatted XML data across a network protocol, commonly HTTP.\cite{java}

SOAP relies on Web Services Description Language (WSDL) defining the web service interface written in XML. WSDL file can be downloaded by potential consumers and defines the interactions between consumers and web services. It describes the message type, port, communication protocol, supported operations, location, and what the client should expect in return. It defines the contract to which the web service guarantees it will conform.

SOAP is designed to provide an independent, abstract communication protocol capable of connecting distributed services. The connected services can be built using any combination of hardware and software that supports a given transport protocol.\cite{java}

The main feature of the SOAP architecture is that it brings it’s own protocol and focuses on exposing pieces of application logic (not data) as services. SOAP is focused on accessing named operations, each implement some business logic through different interfaces.

Though SOAP is commonly referred to as ``web services" this is a misnomer. SOAP in principle has very little if anything to do with the Web.\cite{spf13} Usage of the HTTP protocol for data transfer in SOAP is only one of many possible use cases.


\subsubsection{Representational State Transfer (REST)}

With the rise of Web 2.0, new kind of web service has gained in popularity: the RESTful web service. Many key web players like Amazon\footnote{Amazon.com, Inc. is an American multinational electronic commerce company.}, Google, and Yahoo! have deprecated their SOAP services in favor of RESTful resource oriented services.\cite{java}

In the REST architectural style, every piece of information is a resource, and these resources are addressed using Uniform Resource Identifiers (URIs), typically links on the web. The resources are acted upon by using a set of simple, well-defined operations. The REST client-server architectural style is designed to use a stateless communication protocol, typically HTTP. 

In REST, clients and servers exchange representations of resources using a defined interface and protocol. These principles encourage RESTful applications to be simple and lightweight, and have high performance.

Resources are given a central role in RESTful architectures. A resource is anything the client might want to reference or interact with, any piece of information that might be worthwhile referencing in a hyperlink. It can be stored in a database, a file, and so forth. Exposing abstract concepts as a resource should be avoided. 

While SOAP-based services rely on WSDL to describe the format of possible requests for a given web service, Web Application Description Language (WADL) is used to expose the possible interactions with a given RESTful web service. It eases client development, which can load and interact directly with the resources. WADL is not mandatory for REST services and is not widely used.\cite{java}


\subsubsection{Conclusion}
The final decision, which architecture to use was quite easy. For our purpose the REST has some important advantages over the SOAP.

REST permits many different data formats where as SOAP only permits XML. While this may seem like it adds complexity to REST because you need to handle multiple formats, it is actually quite beneficial. JSON format usually is a better fit for data and parses much faster. REST allows better support for browser clients due to its support for JSON.

REST has better performance and scalability. REST reads can be cached, SOAP based reads cannot be cached.

It’s also worth mentioning that Yahoo! uses REST for all their services including Flickr\footnote{Best online photo management and sharing application in the world.}. Amazon and eBay\footnote{The largest online marketplace.} provide both though Amazon’s internal usage is nearly all REST source. Google used to provide only SOAP for all their services, but in 2006 they deprecated in favor of REST source.\cite{google}

To be correct there are some cases when SOAP is a better option. For example if ACID\footnote{Atomicity, Consistency, Isolation, Durability (ACID) is a set of properties that guarantee that database transactions are processed reliably.} transactions over a service is needed. While REST supports transactions, it isn’t as comprehensive and isn’t ACID compliant. Fortunately ACID transactions are not needed in our similarity framework. REST is limited by HTTP itself, which can’t provide two-phase commit across distributed transactional resources, but SOAP can. 

In summary, SOAP is clearly useful, and important. For instance, if we were writing an application to interface with a bank the better solution would definitely be SOAP. For example, if we were transferring money from one account to the other, we would need to be certain that it completed. Retrying it could be catastrophic if it succeeds the first time, but the response failed.\cite{spf13}

However our framework will benefit much more from simplicity and scalability so the final decision is RESTful web service.


\subsection{Content negotiation}
Now we know what web service architecture will be used and it is time to decide what MIME type shall be used for information and data exchange. The most common type for web services are XML (\textit{text/xml}, \textit{application/xml}) and JSON (\textit{application/json}). Most of applications and programming languages are capable of parsing both of these formats and thus for simple structured data it’s often a question of personal preference, which format to use.

It should be noted that request MIME type can be also an image, video, audio, etc. These types will not be discussed since they are not needed in out framework.

It exceeds the scope of this thesis to discuss all features of XML or JSON documents. In brief, XML is more complex and supports wide range of different data structures. XML has namespaces and can be extended very easily. JSON however is much more simple and faster to parse. It is also an object notation so it naturally fits to object oriented programming while XML may not. In addition all big players like Twitter, Google and Amazon support only JSON or both formats for their web services.

There is a lot of controversy on this topic. In our scope of web service providing simple structural data both formats are freely interchangeable. Nevertheless both formats should be supported so client can decide arbitrarily.

Fortunately there is a mechanism called ``content negotiation" based on \textit{Accept-Encoding} HTTP header. The client sends a request to specific resource on one URI and in HTTP header specifies what type of content they want to receive. This given, the server sends back appropriate MIME type and specify \textit{Content-Type} header correctly.

Java EE supports this natively and only thing needed is to add one annotation to the resource class (see Fig. \ref{contentNego})

\begin{figure}
\begin{lstlisting}
@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
\end{lstlisting}
\caption{Java EE annotation used for content negotiation.}
\label{contentNego}
\end{figure}

We will be using JSON in our example client application (see Section XY).

\subsection{Error handling}
As mentioned earlier REST web service and HTTP protocol is the only way of communication between the application and the client. However during request for similarity searching and many other requests a lot of different errors may occur.

HTTP is capable of simple error handling via its status codes. Unfortunately this is not sufficient since these codes are designed to report errors during HTTP communication only and wont describe internal errors inside the specific application. Every error of this kind is mapped to HTTP status 500 (Internal server error). Its obvious that this gives us no idea what is wrong. Query compound may be malformed or there is some problem with the database.

There are several ways how to handle errors in RESTful web service.

\subsubsection{HTTP Error Codes}
As mentioned before, in this approach we stick to the HTTP error codes. There are many error codes that may be used and describe the error sufficiently. For example if molecule with a given ID were not found, status 404 (Not found) would be suitable. Unfortunately in this case we don’t know whether the resource itself was not found or the molecule with given ID does not exist. 

As mentioned before this approach is not sufficient especially when application wants to send information about specific error or some guidance how this error can be avoided. 

\subsubsection{Extended HTTP headers}
In this scenario, the web service always returns an HTTP 200 OK Status Code, but specifies an application specific error code within a separate HTTP Header. In other words custom HTTP header is attached to the response with corresponding message, which is readable by the script.

\subsubsection{Return error document}
In this scenario, the web service always returns an HTTP status code of 200, but also includes an XML/JSON document containing an application specific error message.

This approach has an advantage that error document can contain detailed structural report about what exactly went wrong.

\subsubsection{Conclusion}
There is no standard solution considered to be ideal for all cases. Finally it was decided that a combination of HTTP error code and custom error header would be used. HTTP error code will indicate that something went wrong and will suggest type of the error (4xx or 5xx status code). The custom HTTP header will be ``Compound-search-error".

The main idea behind this decision is that client application will know about the error simply from HTTP header and eventually may look up the custom header for detailed information. If there is no custom header attached we know that error is in HTTP communication and not in the application.

Another advantage of this approach is that client doesn’t have to parse error documents, which would add unnecessary complexity to the client side.

\subsection{State-full HTTP requests}
As mentioned earlier HTTP protocol is state-less and thus no information is kept between two requests. No client context is being stored on the server and every HTTP request happens in complete isolation. This is sufficient for most use cases in RESTful architecture where client calls one resource gets response and communication is terminated. 

However as we saw in Section \ref{scalabilityRef}, in our framework it is very unreasonable to send thousands of similarity results within the response. Therefore we need to save these results on the server side and then let the consumer retrieve them in further requests. This is definitely a state-full behavior.

Fortunately there are ways how to make state-less HTTP communication state-full. In fact since HTTP 1.1, all connections are considered persistent unless declared otherwise. However this persistence only means that multiple requests can use single TCP connection. No keep-alive messages are sent between server and clients. Connection is kept opened unless a \textit{Connection} header including the connection-token ``close" was sent in the request or connection timeout occurred (see Fig. \ref{fig:persistence}). 

\begin{figure}
  \centering
  \includegraphics[width=8cm]{img/persistence.png}
  \caption{Schema of multiple vs. persistent connection.\cite{wikipersistent}}
  \label{fig:persistence}
\end{figure}

Unfortunately we cannot use this persistence behavior for saving search results on the server side. That is because connection needs to stay opened whole time we want to keep the results (it may be 10 minutes or more). This would cause performance problems in heavily loaded web service. Server processes would be occupied waiting on connections with idle clients.

Another way how to achieve desired state-full behavior is to use session tokens. A session token is a unique identifier that is generated and sent from the server to the client to identify the current interaction session. Token is sent in HTTP header \textit{Set-Cookie} (see Fig. \ref{sessionToken}). The consumer usually stores this token and attach it to further requests header. Thanks to this token server is able to identify the user between HTTP requests. In this scenario no connections are kept open and still server is able to provide specific data for specific client unless session token has expired. These tokens are used in our REST similarity resource and default session timeout is set to 10 minutes.

\begin{figure}
\begin{lstlisting}
Set-Cookie: JSESSIONID=18ae3311d82203dd44baf29fe63f; Path=/Similarity_maven; HttpOnly
\end{lstlisting}
\caption{\textit{Set-Cookie} header in HTTP response of GlassFish application server.}
\label{sessionToken}
\end{figure}

As the name of HTTP header \textit{Set-Cookie} suggests this mechanism is based on cookies. Cookies are small piece of data stored on client’s side. There are many different types of cookies storing different types of data. For instance Persistent cookie holds information for a log period of time and Secure cookie is used only in HTTP secure requests. We will take advantage of Session cookies that are stored in temporary memory and are valid only for limited period of time or until web browser is closed. In this cookie we will keep identification number of current session, which was sent by the server.

This is the only way how to make RESTful web service state-full and this approach is widely used.
Unfortunately this state-fullness has big impact on memory consumption. In Java EE there are three kinds of so-called Session beans that are used for REST web service implementation:

\begin{itemize}
\item  \textbf{Stateless}: This type of session bean does not maintain any conversational state on behalf of a client application. It is used to handle tasks that can be concluded with a single method call.
\item  \textbf{Stateful}: This type of bean maintains state and is associated with a specific client. It is useful for tasks that have to be done in several steps.
\item  \textbf{Singleton}: This type of bean follows the singleton design pattern. The container will make sure that only one instance exists for the entire application.
\end{itemize}

As we see the stateless session bean is a perfect candidate for typical state-less communication while Stateful bean uses session tokens to pair with the client and will serve for similarity searching resource. Singleton session bean will not be discussed since it is used in special cases and design patters that we will not use.

Stateless session beans are the most efficient kind because they can be pooled and shared by several clients. This means that for each stateless bean, the container keeps a certain number of instances in memory (i.e., a pool) and shares them between clients. Because stateless beans have no client state, all instances are equivalent. When a client invokes a method on a stateless bean, the container picks up an instance from the pool and assigns it to the client. When the client request finishes, the instance returns to the pool to be reused. This means only a small number of beans are needed to handle several clients. The container doesn’t guarantee the same instance for the same client.\cite{java}

When a client invokes a stateful session bean however, the EJB container\footnote{An Enterprise JavaBeans (EJB) container provides a run-time environment for session beans within the application server.} needs to provide the same instance for each subsequent method invocation. Stateful beans cannot be reused by other clients. As far as the developer is concerned, no extra code is needed, as this one-to-one correlation is managed automatically by the EJB container.

The one-to-one correlation comes at a price because, as we might have guessed, if you have one million clients, you will get one million stateful beans in memory. To avoid such memory footprint, stateful beans have to be cleared temporarily from memory before the next request from the client brings them back. This technique is called passivation and activation. Passivation is the process of removing an instance from memory and saving it to a persistent location (a file on a disk, a database, etc.).\cite{java}. This behavior is also managed automatically by EJB container. However session bean being passivated should free all resources in use such as database connection.

This given only the similarity resource is state-full in the framework. All other REST resources are implemented as stateless session beans. 

\subsection{REST resources of the framework}
\label{restRef}
According to RESTful web service architecture all functionalities of the framework are exposed as a resource via specific URIs:

\begin{itemize}
\item \texttt{/id/\{id\}/} \\
\textbf{Method: GET} \\ 
Returns molecule with a given id from current database or status 404 if compound was not found.

\item \texttt{/list/} \\
\textbf{Method: GET} \\ 
Returns all compounds from current database. If database contains no molecules status 404 is returned. Usage of this method is not recommended if database contains more than 1000 molecules. 

\item \texttt{/list/\{limit\}/} \\
\textbf{Method: GET} \\ 
Returns specified number of first compounds (limit) from current database. If database contains no molecules status 404 is returned. 

\item \texttt{/list/\{limit\}/\{start\}/} \\
\textbf{Method: GET} \\ 
Returns specified number of first compounds (limit) from current database. If database contains no molecules status 404 is returned. 

\item \texttt{/list/count/} \\
\textbf{Method: GET} \\ 
Returns number of compounds in current database. If database contains no compounds 0 is returned. 

\item \texttt{/add/} \\
\textbf{Method: POST} \\ 
Adds specified compound in MDL molfile to current database and computes appropriate descriptors such as fingerprint for substructure searching. When compound is added successfully HTTP status 201 (Created) and link to the new resource is returned.

If any error occurs response with status 500 (Internal server error) is returned and header \textit{Compound-search-error} is added to HTTP response explaining the error.

\textbf{POST parameters:} \\
\texttt{Molfile} – Molecule to add in MDL molfile string. 


\item \texttt{/similarity/} \\
\textbf{Method: POST} \\ 
Calling this resource initiates similarity searching with chosen similarity on specified query molecule. Only number of results and session token are returned. Results are saved on the server side (see Section \ref{scalabilityRef}) and may be retrieved by calling \texttt{/similarity/\{limit\}/} or \texttt{/similarity/\{limit\}/\{start\}/} resource.

If requested similarity is not found HTTP status 404 is returned with corresponding error message in custom header and if any other error occurs HTTP status 500 is returned.

\textbf{POST parameters:} \\
\texttt{Molfile} – Query molecule in MDL molfile string. \\
\texttt{Similarity} – Name of the similarity to use. \\
\texttt{Parameters} – Array of parameters for required similarity. 


\item \texttt{/similarity/info/} \\
\textbf{Method: GET} \\ 
Returns all available similarities in REST resource and their parameters.  

\item \texttt{/similarity/count/} \\
\textbf{Method: GET} \\ 
Returns number of results from similarity searching from current session. If there are no previous results or session token has expired 404 HTTP status is returned. 

\item \texttt{/similarity/\{limit\}/} \\
\textbf{Method: GET} \\ 
Returns specified number (limit) of best results of similarity searching in current session. If there are no results or session has expired 404 HTTP status is returned. 

\item \texttt{/similarity/\{limit\}/\{start\}} \\
\textbf{Method: GET} \\ 
Returns specified number (limit) of best results of similarity searching in current session starting from specified number (start). This resource is used for result pagination. If there are no results or session has expired 404 HTTP status is returned. 

\item \texttt{/file/process/} \\
\textbf{Method: POST} \\ 
This resource is for experimental purposes only. It is used for testing when programmer does not have database of compounds and wants to load SDF molfile. Resource processes SDF molfile specified locally directly in the source code. It also computes all descriptors for each molecule and save them to the current database. If SDF file contains some malformed molecules they are skipped silently. 

This resource is subject for further improvements. It was decided not to implement uploading of SDF file in initial version because of many problems connected with reading and parsing the SDF file. For instance there are problems with bonds order 4 since they are not present and must be deduced. Next problem is connected with malformed SDF files commonly present in real-world environment. During the testing it was discovered that some cheminformatic programs produce SDF files violating the specification and cannot not be read as expected. These problems fall mostly to the field of chemistry and exceed the scope of the thesis. 
\end{itemize}











\section{Example usage of the framework}
Now we have everything we need to get started. This section provides a simple example of the framework usage.

We will build a new custom similarity based on molecular weight. First thing we need is to define new descriptor that will provide the molecular weight of a given compound. Lets name it \textit{MolWeightDescriptor}.

As mentioned in previous sections, our new descriptor has to implement the \textit{ICompoundDescriptor} interface and thus will override the \textit{calculate(IAtomContainer)} method. Our new descriptor will use the CDK library for molecular weight retrieval that accepts the \textit{IAtomContainer} type as a parameter. Return value will be of type \textit{Double} (see Fig. \ref{MolWeightDescriptorCode}).

\begin{figure}
\begin{lstlisting}
public class MolWeightDescriptor implements ICompoundDescriptor {
    
    public MolWeightDescriptor() {
	
    }

    @Override
    public Double calculate(AtomContainer c) throws CompoundSearchException {
	
	// Inicialization of CDK molecular weight descriptor
	WeightDescriptor wd = new WeightDescriptor();	
	
	// Returns result converted to Double
	return Double.parseDouble(wd.calculate(c).getValue().toString());
	
    } 
}
\end{lstlisting}
\caption{Descriptor returning molecular weight of given molecule using CDK.}
\label{MolWeightDescriptorCode}
\end{figure}

As we see it’s very simple to define this kind of descriptor using CDK. However if a programmer for some reason does not want to use CDK for computations, \textit{IAtomContainer} can be converted to any common chemical format. 

Figure \ref{ConvertAtomToMDL} shows how to convert \textit{IAtomContainer} to MDL format using \textit{MDLV2000Writer}. Complete list of supported format can be found in PRILOHA XY.

\begin{figure}
\begin{lstlisting}
ByteArrayOutputStream baos = new ByteArrayOutputStream();
MDLV2000Writer m2w = new MDLV2000Writer(baos);
m2w.write(IAtomContainer);
m2w.close();
String MDLmolfile = new String(baos.toByteArray(), "UTF-8");
\end{lstlisting}
\caption{Converting \textit{IAtomContainer} object to MDL format using \textit{MDLV2000Writer} from CDK.}
\label{ConvertAtomToMDL}
\end{figure}

Now we have a descriptor implemented and thus we can build similarity operating over it. Lets name it \textit{MolWeightSimilarity}.

We know from the previous section that our new similarity has to implement the \textit{ISimilarity} interface and we also know that the \textit{AbstractSimilarity} class provides basic implementation and default behavior. In this case it is sufficient to extend the abstract class. 

Our molecular weight similarity will have two parameters. First of them will be the value of minimal similarity of interest. If one does not specify this parameter, the default value will be 0.8 defined in \textit{AbstractSimilarity}. The second is the number of results we want to retrieve. Only this number of most similar compounds is then returned.

Extending AbstractSimilarity programmer has to implement:
\begin{itemize}
\item Constructor for new similarity. One constructor without parameters is required in order to have new similarity available automatically via reflection in REST web service (see Section \ref{restRef}). 
\item Override \textit{setRequestCompound(ICompound)} method as setter for query compound. Descriptor computations are usually present here.
\item Override \textit{screen(start, limit)} method if there is any database screening in the similarity. If there is no screening this method can be omitted.
\item Override \textit{calculateSimilarity(AtomContainer)} method. This is where similarity calculation is performed.
\item Parameter handling by overriding \textit{setParameters(parameters)}, \textit{getParameters()}, \textit{getParameterNames()} and \textit{getParameterType(parameter)} methods. Descriptions of these methods were discussed in Section \ref{coreEntit}.
\item Compound retrieval from database in methods \textit{getCompounds(start, limit)} and   \textit{getCompoundById(id)}.
\end{itemize}

First of all we implement constructors and compound setter (see Fig. \ref{MolWeightSimilarity1}). Notice that we have two private variables, one for descriptor instance and second for descriptor value of query compound. The second one is for scalability reasons because we do not want to compute the descriptor of the query molecule each time two compounds are compared. 

\begin{figure}
\begin{lstlisting}
public class MolWeightSimilarity extends AbstractSimilarity {

    // Descriptor for molecular weight retrieval
    private ICompoundDescriptor molWeightDescriptor;
    // Result of the molecular weight descriptor
    private Double mwdRequestResult;

    public MolWeightSimilarity(ICompound c) throws CompoundSearchException {
	this.requestCompound = c;

	this.molWeightDescriptor = new MolWeightDescriptor();
	this.mwdRequestResult = (Double) this.molWeightDescriptor.calculate(this.requestCompound.getAtomContainer());
    }

    public MolWeightSimilarity() {
	this.molWeightDescriptor = new MolWeightDescriptor();
    }

    @Override
    public void setRequestCompound(ICompound c) throws CompoundSearchException {
	this.requestCompound = c;
	this.mwdRequestResult = (Double) this.molWeightDescriptor.calculate(this.requestCompound.getAtomContainer());
    }
}

\end{lstlisting}
\caption{Implementation of contructors and compound setter in the \textit{MolWeightSimilarity}.}
\label{MolWeightSimilarity1}
\end{figure}

In our case there is no database screening necessary since molecular weight computation is very fast. If the programmer wants to have some screening, however, they can screen for example over number of atoms. In other words if the required molecular weight is very small we can rapidly discard molecules with a large number of atoms.

Now we add the implementation of similarity computation. Similarity is defined as the ratio of molecular weights between query and given molecule (see Fig. \ref{MolWeightSimilarity2}).

\begin{figure}
\begin{lstlisting}
@Override
public Double calculateSimilarity(AtomContainer c) throws CompoundSearchException {
    Double requestMolWeight = Double.parseDouble(this.mwdRequestResult.toString());
    Double currentMolWeight = Double.parseDouble(this.molWeightDescriptor.calculate(c).toString());

    Double similarity = (double) Math.min(requestMolWeight, currentMolWeight) / Math.max(requestMolWeight, currentMolWeight);

    return similarity;
}
\end{lstlisting}
\caption{Implementation of similarity computation in \textit{MolWeightSimilarity}.}
\label{MolWeightSimilarity2}
\end{figure}


The next step is parameter handling. As mentioned earlier, our molecular weight similarity will accept two parameters - the minimum required similarity (\textit{threshold}) and the number of best results (\textit{numberOfResults}).  

First of all we create a setter that accepts a list of parameters. This is also the ideal place for parameter validation. If validation fails \textit{CompoundSearchException} with corresponding message explaining the error needs to be thrown (see Fig. \ref{MolWeightSimilarity3}). Web service will then return HTTP response with status code of 500 and will attach the error message. 

\begin{figure}
\begin{lstlisting}
@Override
public void setParameters(List<String> parameters) throws CompoundSearchException {

    if (parameters.size() != 2) {
        throw new CompoundSearchException("MolWeightSimilarity requires 2 parameters");
    }

    try {
        this.threshold = Double.parseDouble(parameters.get(0));
        if (this.threshold <= 0) {
            throw new CompoundSearchException("MolWeightSimilarity threshold parameter cannot be less or equal to 0.");
        }
    } catch (NumberFormatException e) {
        throw new CompoundSearchException("MolWeightSimilarity threshold parameter must be of type Double");
    }
	
    try {
        this.numberOfResults = Integer.parseInt(parameters.get(1));	
        if (this.numberOfResults <= 0) {
            throw new CompoundSearchException("MolWeightSimilarity numberOfResults parameter cannot be less or equal to 0.");
        }
    } catch (NumberFormatException e) {
        throw new CompoundSearchException("MolWeightSimilarity numberOfResults parameter must be of type Integer");
    }
}

\end{lstlisting}
\caption{Implementation of the parameter setter and parameter validation in \textit{MolWeightSimilarity}.}
\label{MolWeightSimilarity3}
\end{figure}


Next parameter methods are listed in Figure \ref{MolWeightSimilarity4}. Method \textit{getParameters()} returns an array of type \textit{Object} because the parameter can by of any data type. On the other hand \textit{getParameterNames()} returns an array of type \textit{String} representing human readable names of parameters that will be presented to client via web service.  And finally \textit{getParameterType(name)} returns a simple \textit{Object} of the same type as similarity parameter with a given name.

\begin{figure}
\begin{lstlisting}
@Override
public Object[] getParameters() {
    Object[] parameters = new Object[2];
    parameters[0] = this.threshold;
    parameters[1] = this.numberOfResults;

    return parameters;
}

@Override
public String[] getParameterNames() {
    String[] names = new String[2];
    names[0] = "treshold";
    names[1] = "numberOfResults";

    return names;
}

@Override
public Object getParameterType(String name) {
    if (name.equals("treshold")) {
         return 0.0;
    }

    if (name.equals("numberOfResults")) {
        return 1;
    }

    return null;
}
\end{lstlisting}
\caption{Implementation of parameter getters in \textit{MolWeightSimilarity}.}
\label{MolWeightSimilarity4}
\end{figure}

The final thing we need to implement is the compound retrieval. Methods \textit{getCompounds(start, limit)} and \textit{getCompoundById(id)} should provide such functionality. These methods are very versatile since compound retrieval can be defined arbitrarily. The programmer can specify the database connection, reading from file or can call a remote application interface. In our example we will call an existing REST resource for compound retrieval (see Section \ref{restRef}). We will obtain a reference to this resource form context of Java application container. This is called dependency injection. Method \textit{getCompounds(start, limit)} is listed in Figure \ref{MolWeightSimilarity5}, the second one is very similar and thus is not listed.

\begin{figure}
\begin{lstlisting}
@Override
public List<? extends ICompound> getCompounds(Integer start, Integer limit) throws CompoundSearchException {
    ListResource lr;
    List<? extends ICompound> result;
    try {
        Context context = new InitialContext();
        lr = (ListResource) context.lookup("java:module/ListResource");
        // Must be set. 404 WebApplicationException is invoked and app stopped when empty result otherwise.
        lr.setCalledFromApp(true);
    } catch (NamingException e) {
        throw new CompoundSearchException("Database error in AtomCountSimilarity. Cannot obtain REST resources.");
    }

    result = lr.getCompounds(limit, start);

    return result;
}
\end{lstlisting}
\caption{Implementation of compound retrieval from REST web service in \textit{MolWeightSimilarity}.}
\label{MolWeightSimilarity5}
\end{figure}

\setsecnumdepth{part}
\chapter{Conclusion}

Conclusion

\bibliographystyle{csn690}
\bibliography{matesbibliography}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[GUI] Graphical user interface
	\item[XML] Extensible markup language
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
